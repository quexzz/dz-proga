#include <iostream>
using namespace std;

// Определение узла для связанного списка
struct Node {
    int data;
    Node* next;

    Node(int val) : data(val), next(nullptr) {}
};

// Определение класса очереди на основе связанного списка
class Queue {
private:
    Node* front; // Указатель на начало очереди
    Node* rear;  // Указатель на конец очереди

public:
    // Конструктор, инициализирующий пустую очередь
    Queue() : front(nullptr), rear(nullptr) {}

    // Метод для добавления элемента в конец очереди
    void enqueue(int val) {
        Node* newNode = new Node(val); // Создаем новый узел
        if (rear == nullptr) { // Если очередь пуста
            front = rear = newNode; // Устанавливаем новый узел как начальный и конечный элементы
        }
        else {
            rear->next = newNode; // Устанавливаем связь текущего последнего элемента с новым элементом
            rear = newNode; // Перемещаем указатель на конец очереди на новый элемент
        }
    }

    // Метод для удаления элемента из начала очереди
    void dequeue() {
        if (front == nullptr) {
            cout << "Очередь пуста. Невозможно выполнить удаление." << endl;
            return;
        }
        Node* temp = front; // Сохраняем указатель на начальный элемент
        front = front->next; // Перемещаем указатель на начало на следующий элемент
        if (front == nullptr) {
            rear = nullptr; // Если после удаления очередь стала пустой, обнуляем указатель на конец
        }
        delete temp; // Освобождаем память, занимаемую предыдущим начальным элементом
    }

    // Метод для циклического сдвига очереди так, чтобы первым элементом был первый нечетный элемент
    void cyclicShift() {
        if (front == nullptr || front->next == nullptr) {
            // Если очередь пуста или содержит только один элемент, выходим из функции
            return;
        }

        Node* current = front; // Указатель на текущий элемент
        Node* prev = nullptr; // Указатель на предыдущий элемент
        Node* firstOdd = nullptr; // Указатель на первый нечетный элемент

        // Находим первый нечетный элемент
        while (current != nullptr && current->data % 2 == 0) {
            prev = current;
            current = current->next;
        }

        // Если нет нечетных элементов, выходим из функции
        if (current == nullptr) {
            return;
        }

        firstOdd = current; // Запоминаем первый нечетный элемент

        // Находим последний элемент
        while (current->next != nullptr) {
            current = current->next;
        }

        // Перемещаем первый нечетный элемент в начало очереди
        rear->next = front; // Связываем текущий последний элемент с начальным элементом
        front = firstOdd; // Обновляем начальный элемент
        rear = prev; // Обновляем указатель на последний элемент
        prev->next = nullptr; // Разрываем связь между последним и новым последним элементами
    }

    // Метод для вывода содержимого очереди
    void display() {
        cout << "Стало: "; // Выводим сообщение перед содержимым очереди
        Node* temp = front; // Указатель для прохода по элементам очереди
        while (temp != nullptr) { // Пока не достигнем конца очереди
            cout << temp->data << " "; // Выводим значение текущего элемента
            temp = temp->next; // Переходим к следующему элементу
        }
        cout << endl;
    }
};

int main() {
    setlocale(LC_ALL, "Russian"); // Установка русской локали
    Queue q; // Создаем объект очереди

    // Вводим элементы очереди
    cout << "Введите элементы очереди (окончание ввода - любая нечисловая последовательность): " << endl;
    int num;
    while (cin >> num) {
        q.enqueue(num);
    }

    // Выполняем циклический сдвиг
    q.cyclicShift();

    // Выводим содержимое очереди после циклического сдвига
    q.display();

    return 0;
}
